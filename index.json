[{"categories":["Development","How To"],"content":"Extracting system icons from Win32 ","date":"2019-04-16","objectID":"/extract-icons-win32/:1:0","tags":["csharp","net framework","API","Win32"],"title":"Extract extra large icon from a file, folder or drive","uri":"/extract-icons-win32/"},{"categories":["Development","How To"],"content":"Overwiew Hi, everyone! :) In a recent project I was required to show a list of files with their associated icons. It doesn’t sounds quite difficult, and in fact it is not. Except if you have to deal with files in network paths or you want to get different icons sizes, apart the typical 32×32. And well, that was the case If you only need local files and sizes of 32x32 píxels you can achieve this using the static method ExtractAssociatedIcon in the class System.Drawing.Icon, but sadly this method doesn’t work with UNC (Universal Naming Convention) paths nor return other sizes that 32×32 pixels. I had to show four different icons sizes including the extra-large icon also called “jumbo”, so I had to some functions and structures from the Win32 API. Of course, if anyone knows a better way to do it, please contact with me ASAP ","date":"2019-04-16","objectID":"/extract-icons-win32/:1:1","tags":["csharp","net framework","API","Win32"],"title":"Extract extra large icon from a file, folder or drive","uri":"/extract-icons-win32/"},{"categories":["Development","How To"],"content":"Show me the (final) code Today I prefer to start from the end so before starting, let’s take a look to the final code: From a file path and the desired size we wanna retrieve the associated icon. var filename = \"\\\\myNetworkResource\\Folder\\SampleDocument.pdf\"; var size = IconSizeEnum.ExtraLargeIcon; var image = GetFileImageFromPath(filename, size); ","date":"2019-04-16","objectID":"/extract-icons-win32/:1:2","tags":["csharp","net framework","API","Win32"],"title":"Extract extra large icon from a file, folder or drive","uri":"/extract-icons-win32/"},{"categories":["Development","How To"],"content":"The ingredients Here are declared all the functions and types we need to use. You can simply paste all this code into a class. [ComImportAttribute()] [GuidAttribute(\"46EB5926-582E-4017-9FDF-E8998DAA0950\")] [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)] private interface IImageList { [PreserveSig] int Add( IntPtr hbmImage, IntPtr hbmMask, ref int pi); [PreserveSig] int ReplaceIcon( int i, IntPtr hicon, ref int pi); [PreserveSig] int SetOverlayImage( int iImage, int iOverlay); [PreserveSig] int Replace( int i, IntPtr hbmImage, IntPtr hbmMask); [PreserveSig] int AddMasked( IntPtr hbmImage, int crMask, ref int pi); [PreserveSig] int Draw( ref IMAGELISTDRAWPARAMS pimldp); [PreserveSig] int Remove( int i); [PreserveSig] int GetIcon( int i, int flags, ref IntPtr picon); }; private struct IMAGELISTDRAWPARAMS { public int cbSize; public IntPtr himl; public int i; public IntPtr hdcDst; public int x; public int y; public int cx; public int cy; public int xBitmap; public int yBitmap; public int rgbBk; public int rgbFg; public int fStyle; public int dwRop; public int fState; public int Frame; public int crEffect; } private struct SHFILEINFO { public IntPtr hIcon; public int iIcon; public uint dwAttributes; [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 254)] public string szDisplayName; [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] public string szTypeName; } private const int SHGFI_SMALLICON = 0x1; private const int SHGFI_LARGEICON = 0x0; private const int SHIL_JUMBO = 0x4; private const int SHIL_EXTRALARGE = 0x2; private const int WM_CLOSE = 0x0010; public enum IconSizeEnum { SmallIcon16 = SHGFI_SMALLICON, MediumIcon32 = SHGFI_LARGEICON, LargeIcon48 = SHIL_EXTRALARGE, ExtraLargeIcon = SHIL_JUMBO } [DllImport(\"user32\")] private static extern IntPtr SendMessage( IntPtr handle, int Msg, IntPtr wParam, IntPtr lParam); [DllImport(\"shell32.dll\")] private static extern int SHGetImageList( int iImageList, ref Guid riid, out IImageList ppv); [DllImport(\"Shell32.dll\")] private static extern int SHGetFileInfo( string pszPath, int dwFileAttributes, ref SHFILEINFO psfi, int cbFileInfo, uint uFlags); [DllImport(\"user32\")] private static extern int DestroyIcon( IntPtr hIcon); ","date":"2019-04-16","objectID":"/extract-icons-win32/:1:3","tags":["csharp","net framework","API","Win32"],"title":"Extract extra large icon from a file, folder or drive","uri":"/extract-icons-win32/"},{"categories":["Development","How To"],"content":"Putting it all together In this code we’re using several API calls to the functions we declared before. You can paste all this code in the same class. Here’s the tricky part: public static System.Drawing.Bitmap GetFileImageFromPath( string filepath, IconSizeEnum iconsize) { IntPtr hIcon = IntPtr.Zero; if (System.IO.Directory.Exists(filepath)) hIcon = GetIconHandleFromFolderPath(filepath, iconsize); else if (System.IO.File.Exists(filepath)) hIcon = GetIconHandleFromFilePath(filepath, iconsize); return GetBitmapFromIconHandle(hIcon); } private static IntPtr GetIconHandleFromFilePath(string filepath, IconSizeEnum iconsize) { var shinfo = new SHFILEINFO(); const uint SHGFI_SYSICONINDEX = 0x4000; const int FILE_ATTRIBUTE_NORMAL = 0x80; uint flags = SHGFI_SYSICONINDEX; return GetIconHandleFromFilePathWithFlags(filepath, iconsize, ref shinfo, FILE_ATTRIBUTE_NORMAL, flags); } private static IntPtr GetIconHandleFromFolderPath(string folderpath, IconSizeEnum iconsize) { var shinfo = new SHFILEINFO(); const uint SHGFI_ICON = 0x000000100; const uint SHGFI_USEFILEATTRIBUTES = 0x000000010; const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010; uint flags = SHGFI_ICON | SHGFI_USEFILEATTRIBUTES; return GetIconHandleFromFilePathWithFlags(folderpath, iconsize, ref shinfo, FILE_ATTRIBUTE_DIRECTORY, flags); } private static System.Drawing.Bitmap GetBitmapFromIconHandle(IntPtr hIcon) { if (hIcon == IntPtr.Zero) return null; var myIcon = System.Drawing.Icon.FromHandle(hIcon); var bitmap = myIcon.ToBitmap(); myIcon.Dispose(); DestroyIcon(hIcon); SendMessage(hIcon, WM_CLOSE, IntPtr.Zero, IntPtr.Zero); return bitmap; } private static IntPtr GetIconHandleFromFilePathWithFlags( string filepath, IconSizeEnum iconsize, ref SHFILEINFO shinfo, int fileAttributeFlag, uint flags) { const int ILD_TRANSPARENT = 1; var retval = SHGetFileInfo(filepath, fileAttributeFlag, ref shinfo, Marshal.SizeOf(shinfo), flags); if (retval == 0) throw (new System.IO.FileNotFoundException()); var iconIndex = shinfo.iIcon; var iImageListGuid = new Guid(\"46EB5926-582E-4017-9FDF-E8998DAA0950\"); IImageList iml; var hres = SHGetImageList((int)iconsize, ref iImageListGuid, out iml); var hIcon = IntPtr.Zero; hres = iml.GetIcon(iconIndex, ILD_TRANSPARENT, ref hIcon); return hIcon; } First, we need to call to SHGetFileInfo function that receives a reference to a structure of type SHFILEINFO, which contains the index of the icon image within the system image list. We will use this index later. Then we’ve to perform a second call to the SHGetImageList function that receives an output parameter with an IImageList structure, which is modified within the function. Once we have that COM interface, we only need to call its GetIcon method, passing a parameter with the desired size, and obtaining a handle to the icon by reference. Finally, using the handle we can create an Icon and then convert it to a Bitmap or BitmapSource: Tip: Don’t forget to destroy the resources (Icon) when working with the Win32 API! For better use I’ve also created an enumeration IconSizeEnum (see types declaration) with the different flags values as well: public enum IconSizeEnum { SmallIcon16 = SHGFI_SMALLICON, MediumIcon32 = SHGFI_LARGEICON, LargeIcon48 = SHIL_EXTRALARGE, ExtraLargeIcon = SHIL_JUMBO } Finally, create a new Form and add a PictureBox named ‘pictureBox1’ a label called ‘labelFilePath’ and a Button, and into the Button’s click event handler use this code: var size = IconSizeEnum.ExtraLargeIcon; var ofd = new OpenFileDialog(); if (ofd.ShowDialog() == System.Windows.Forms.DialogResult.OK) { labelFilePath.Text = ofd.FileName; pictureBox1.Image = YourClassNameHere.GetFileImageFromPath(ofd.FileName, size); } You can also use UNC paths, including network paths :) Hope this helps! ;) ","date":"2019-04-16","objectID":"/extract-icons-win32/:1:4","tags":["csharp","net framework","API","Win32"],"title":"Extract extra large icon from a file, folder or drive","uri":"/extract-icons-win32/"},{"categories":["Development","How To"],"content":"Gettings all controls from a container v2 ","date":"2010-11-15","objectID":"/retrieve-all-controls-using-generics-ii/:1:0","tags":["csharp","net framework","generics","LINQ"],"title":"Retrieve all controls using generics (II)","uri":"/retrieve-all-controls-using-generics-ii/"},{"categories":["Development","How To"],"content":"A better approach In my previous post I created a recursive function to retrieve all controls inside a form and its containers. Today, my colleague and friend Eduard Tomàs sent me another solution to the same topic based on LINQ. It’s simply and really, really pretty ❤️ ","date":"2010-11-15","objectID":"/retrieve-all-controls-using-generics-ii/:1:1","tags":["csharp","net framework","generics","LINQ"],"title":"Retrieve all controls using generics (II)","uri":"/retrieve-all-controls-using-generics-ii/"},{"categories":["Development","How To"],"content":"The power of LINQ Before starting, we need to solve this: LINQ works over IEnumerable, but Control.Controls property returns a ControlCollection type. In fact, nowadays, since we have Generics this class has no sense (like other 1.000 similar classes) but remember that Generics doesn’t appeared until .NET Framework 2.0. So, our first step will be retrieve an IEnumerable from a ControlCollection property of a Control. This could be accomplished using an extensor method over the class ControlCollection: public static IEnumerable\u003cControl\u003e AsEnumerable(this Control.ControlCollection @this) { foreach (var control in @this) yield return (Control)control; } Note that using this method we are able to transform CollectionControl to IEnumerable and get full access to the power of Linq. Now, let’s create a method to retrieve all controls of a type: public static IEnumerable\u003cT\u003e GetAllControls\u003cT\u003e(this Control @this) where T : Control { return @this.Controls.AsEnumerable().Where( x =\u003e x.GetType() == typeof(T)).Select( y =\u003e (T)y).Union( @this.Controls.AsEnumerable().SelectMany( x =\u003e GetAllControls\u003cT\u003e(x)).Select(y =\u003e (T)y)); } It looks cool, isn’t it? No loops, no ifs… only pure LINQ power! :-) Note that converting Controls property into an Enumerable allow us to use all those IEnumerable LINQ methods like Select, Where, Union or SelectMany… in just a single line of code! This is amazing, this is functional programming style! ","date":"2010-11-15","objectID":"/retrieve-all-controls-using-generics-ii/:1:2","tags":["csharp","net framework","generics","LINQ"],"title":"Retrieve all controls using generics (II)","uri":"/retrieve-all-controls-using-generics-ii/"},{"categories":["Development","How To"],"content":"Applying several actions There’s also a small difference with my original solution. In the previous one I used an internal List to copy all controls references. The new one only iterates over the original collection. There’s no internal lists. Another difference present in LINQ solution is we are returning an IEnumerable, so we loose the ForEach method (because IEnumerable doesn’t implements this method). But building our own ForEach method is as trivial as: public static void ForEach\u003cT\u003e(this IEnumerable\u003cT\u003e @this, Action\u003cT\u003e action) { foreach (T t in @this) { action(t); } } Now, we’ve all the necessary ingredients to get all controls and do whatever we need :D this.GetAllControls\u003cTextBox\u003e().ForEach(p =\u003e p.Enabled = false); this.GetAllControls\u003cTextBox\u003e().ForEach(p =\u003e { p.BackColor = Color.LightGray; p.ForeColor = Color.Red; p.Text = \"hello\"; p.TextAlign = HorizontalAlignment.Center; }); HYEI, happy coding! :-) November 2010 ","date":"2010-11-15","objectID":"/retrieve-all-controls-using-generics-ii/:1:3","tags":["csharp","net framework","generics","LINQ"],"title":"Retrieve all controls using generics (II)","uri":"/retrieve-all-controls-using-generics-ii/"},{"categories":["Development","How To"],"content":"Gettings all controls from a container ","date":"2010-11-09","objectID":"/retrieve-all-controls-using-generics-i/:1:0","tags":["csharp","net framework","generics"],"title":"Retrieve all controls using generics (I)","uri":"/retrieve-all-controls-using-generics-i/"},{"categories":["Development","How To"],"content":"That’s the question How many times have you ever heard something similar? :) How to clear the content of all the textboxes in a form? The question may vary a littles bit but it’s always related to obtain all controls of a determined type (Button TextBox, etc) in a form or maybe in another type of container like a Panel or user control. ","date":"2010-11-09","objectID":"/retrieve-all-controls-using-generics-i/:1:1","tags":["csharp","net framework","generics"],"title":"Retrieve all controls using generics (I)","uri":"/retrieve-all-controls-using-generics-i/"},{"categories":["Development","How To"],"content":"Generics and Extension methods Using generics it’s really easy! Firstly let’s create an extensor method, that returns a collection of all the controls of a type in a Form or container. And then, we will use this collection to do an action over each returned item. The extensor method public static List\u003cT\u003e GetControls\u003cT\u003e(this Control container) where T : Control { List\u003cT\u003e controls = new List\u003cT\u003e(); foreach (Control c in container.Controls) { if (c is T) controls.Add((T)c); controls.AddRange(GetControls\u003cT\u003e(c)); } return controls; } This method retrieves the collection of Controls from a container calling it itself recursively, retrieving the content of all his containers. How to use it? this.GetControls\u003cTextBox\u003e().ForEach(p =\u003e p.Text = string.Empty); We can use the extensor method directly into a form because Form class inherits from ContainerControl, that inherits from ScrollableControl, and ScrollableControl from Control. Or, in other words, our Form will implement our extensor method. So, at compile time we should specify the type of the controls we want to retrieve. In the example we are using TextBox, but you can use Button type instead. And then, use ForEach to apply an action on each one of the items returned. Moreover, if we want to retrieve only the controls into a container (GroupBox, Panel, TabControl or another that inherits from Control), you can call the method for this particular control. myPanel.GetControls\u003cButton\u003e().ForEach(p =\u003e p.Enabled = false); Applying several actions In most cases, we would apply several actions to each control (not only one). In this case it’s quite easy: The only thing we have to do is create a method that receives a parameter of this type, and call it passing the control as an argument: this.GetControls\u003cTextBox\u003e().ForEach(p =\u003e ApplyFormat(p)); private void ApplyFormat(TextBox text) { text.BackColor = Color.LightGray; text.ForeColor = Color.Red; text.Text = \"hello\"; text.TextAlign = HorizontalAlignment.Center; } Or maybe, using an ‘action delegate’, both options are correct: this.GetControls\u003cTextBox\u003e().ForEach(p =\u003e { p.BackColor = Color.LightGray; p.ForeColor = Color.Red; p.Text = \"hello\"; p.TextAlign = HorizontalAlignment.Center; }); Happy coding! :-) November 2010 ","date":"2010-11-09","objectID":"/retrieve-all-controls-using-generics-i/:1:2","tags":["csharp","net framework","generics"],"title":"Retrieve all controls using generics (I)","uri":"/retrieve-all-controls-using-generics-i/"}]